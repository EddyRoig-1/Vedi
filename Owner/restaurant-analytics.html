<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analytics Dashboard - Restaurant Management</title>
    
    <!-- Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>

    <!-- Secure Iframe Initialization -->
    <script src="../Api/core/secure-iframe-init.js"></script>
    
    <!-- Restaurant Timezone Support -->
    <script src="../Api/business/timezone.js"></script>

    <!-- Chart.js for visualizations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: #F8F9FA;
            min-height: 100vh;
            color: #1D1D1F;
            line-height: 1.5;
        }

        /* Main Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 32px;
        }

        /* Loading State */
        .loading-spinner {
            display: none;
            text-align: center;
            padding: 80px 32px;
            color: #8E8E93;
        }

        .loading-spinner.show {
            display: block;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 2px solid #E5E5E7;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error Message */
        .error-message {
            background: #FFEBEE;
            color: #C62828;
            padding: 16px 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            border: 1px solid #FFCDD2;
            display: none;
            font-weight: 500;
        }

        /* Controls Section */
        .controls-section {
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid #E5E5E7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .page-title {
            font-size: 34px;
            font-weight: 700;
            color: #000000;
            margin: 0;
        }

        .time-period-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-label {
            font-size: 15px;
            font-weight: 600;
            color: #1D1D1F;
        }

        .time-period-selector {
            padding: 12px 16px;
            border: 1px solid #E5E5E7;
            border-radius: 22px;
            font-size: 15px;
            background: #FFFFFF;
            color: #1D1D1F;
            min-height: 44px;
            font-family: inherit;
            transition: border-color 0.2s ease;
            font-weight: 500;
            text-align: center;
        }

        .time-period-selector:focus {
            outline: none;
            border-color: #007AFF;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
        }

        .btn-primary {
            background: #007AFF;
            color: #FFFFFF;
            border: none;
            padding: 12px 20px;
            border-radius: 22px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary:hover {
            background: #0056CC;
        }

        .btn-secondary {
            background: #F2F2F7;
            color: #1D1D1F;
            border: none;
            padding: 12px 20px;
            border-radius: 22px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-secondary:hover {
            background: #E5E5EA;
        }

        /* KPI Cards */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .kpi-card {
            background: #FFFFFF;
            padding: 20px;
            border-radius: 16px;
            border: 1px solid #E5E5E7;
            text-align: center;
            transition: all 0.2s ease;
        }

        .kpi-card:hover {
            border-color: #007AFF;
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.1);
        }

        .kpi-title {
            font-size: 13px;
            font-weight: 600;
            color: #8E8E93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .kpi-value {
            font-size: 28px;
            font-weight: 700;
            color: #000000;
            margin-bottom: 8px;
        }

        .kpi-change {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 13px;
            font-weight: 500;
        }

        .kpi-change.positive {
            color: #34C759;
        }

        .kpi-change.negative {
            color: #FF3B30;
        }

        .kpi-change.neutral {
            color: #8E8E93;
        }

        /* Chart Sections */
        .chart-section {
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid #E5E5E7;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #F2F2F7;
        }

        .section-title {
            font-size: 22px;
            font-weight: 600;
            color: #000000;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 16px;
        }

        .chart-container.dual {
            height: 200px;
            margin-bottom: 12px;
        }

        .chart-small {
            height: 300px;
        }

        .dual-charts-container {
            display: none;
        }

        .dual-charts-container.show {
            display: block;
        }

        .single-chart-container {
            display: block;
        }

        .single-chart-container.hide {
            display: none;
        }

        /* Analytics Grid */
        .analytics-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        /* Insights Section */
        .insights-section {
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            border: 1px solid #E5E5E7;
        }

        .insight-item {
            background: #F8F9FA;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid #007AFF;
        }

        .insight-item:last-child {
            margin-bottom: 0;
        }

        .insight-item.positive {
            border-left-color: #34C759;
            background: #F0FDF4;
        }

        .insight-item.warning {
            border-left-color: #FF9500;
            background: #FFF8F0;
        }

        .insight-item.negative {
            border-left-color: #FF3B30;
            background: #FFF0F0;
        }

        .insight-title {
            font-weight: 600;
            color: #000000;
            margin-bottom: 4px;
            font-size: 15px;
        }

        .insight-description {
            color: #8E8E93;
            font-size: 13px;
            line-height: 1.4;
        }

        /* Tables */
        .table-container {
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            border: 1px solid #E5E5E7;
            margin-bottom: 24px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 auto 16px auto;
        }

        .data-table th,
        .data-table td {
            padding: 12px 16px;
            text-align: center;
            border-bottom: 1px solid #F2F2F7;
        }

        .data-table th {
            background: #F8F9FA;
            color: #1D1D1F;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-table td {
            color: #1D1D1F;
            font-size: 15px;
        }

        .data-table tr:hover {
            background: #F8F9FA;
        }

        .metric-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-badge.high {
            background: #E8F5E8;
            color: #2E7D32;
        }

        .metric-badge.medium {
            background: #FFF3E0;
            color: #E65100;
        }

        .metric-badge.low {
            background: #FFEBEE;
            color: #C62828;
        }

        /* Customer Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .metric-card {
            background: #F8F9FA;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid #E5E5E7;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #000000;
            margin-bottom: 4px;
        }

        .metric-label {
            color: #8E8E93;
            font-size: 13px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 32px;
            color: #8E8E93;
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #1D1D1F;
        }

        .empty-description {
            font-size: 15px;
            line-height: 1.4;
        }

        /* Filter Select in Charts */
        .filter-select {
            padding: 8px 12px;
            border: 1px solid #E5E5E7;
            border-radius: 8px;
            font-size: 13px;
            background: #FFFFFF;
            color: #1D1D1F;
            font-family: inherit;
            transition: border-color 0.2s ease;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%238E8E93" d="M6 8L0 0h12z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 28px;
        }

        .filter-select:focus {
            outline: none;
            border-color: #007AFF;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            .controls-section {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }

            .action-buttons {
                justify-content: center;
            }

            .kpi-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .chart-container {
                height: 300px;
            }

            .page-title {
                font-size: 28px;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading State -->
    <div id="loadingSpinner" class="loading-spinner">
        <div class="spinner"></div>
        <p>Loading analytics...</p>
    </div>

    <!-- Error State -->
    <div id="errorMessage" class="error-message">
        <strong>Error:</strong> <span id="errorText"></span>
    </div>

    <!-- Main Content -->
    <div id="mainContent" style="display: none;">
        <div class="container">
            <!-- Page Header & Controls -->
            <div class="controls-section">
                <div class="time-period-group">
                    <h1 class="page-title">Analytics Overview</h1>
                </div>
                <div class="action-buttons">
                    <div class="time-period-group">
                        <select class="time-period-selector" id="timePeriodSelect">
                            <option value="today">Today</option>
                            <option value="week">This Week</option>
                            <option value="month" selected>This Month</option>
                            <option value="quarter">This Quarter</option>
                            <option value="year">This Year</option>
                        </select>
                    </div>
                    <button class="btn-primary" onclick="exportAnalytics()">Export</button>
                </div>
            </div>

            <!-- Key Performance Indicators -->
            <div class="kpi-grid">
                <div class="kpi-card">
                    <div class="kpi-title">Total Revenue</div>
                    <div class="kpi-value" id="totalRevenue">$0</div>
                    <div class="kpi-change" id="revenueChange">
                        <span>+0% from last period</span>
                    </div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-title">Total Orders</div>
                    <div class="kpi-value" id="totalOrders">0</div>
                    <div class="kpi-change" id="ordersChange">
                        <span>+0% from last period</span>
                    </div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-title">Unique Customers</div>
                    <div class="kpi-value" id="uniqueCustomers">0</div>
                    <div class="kpi-change" id="customersChange">
                        <span>+0% from last period</span>
                    </div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-title">Avg Order Value</div>
                    <div class="kpi-value" id="avgOrderValue">$0</div>
                    <div class="kpi-change" id="aovChange">
                        <span>+0% from last period</span>
                    </div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-title">Total Losses</div>
                    <div class="kpi-value" id="totalLosses">$0</div>
                    <div class="kpi-change" id="lossesChange">
                        <span>0 incidents</span>
                    </div>
                </div>
            </div>

            <!-- Main Analytics Section -->
            <div class="analytics-grid">
                <!-- Revenue Trends Chart -->
                <div class="chart-section">
                    <div class="section-header">
                        <h3 class="section-title" id="chartTitle">Revenue & Order Trends</h3>
                        <select class="filter-select" id="revenueChartType">
                            <option value="revenue">Revenue</option>
                            <option value="orders">Order Count</option>
                            <option value="both">Both</option>
                        </select>
                    </div>
                    
                    <!-- Single Chart Container -->
                    <div class="single-chart-container" id="singleChartContainer">
                        <div class="chart-container">
                            <canvas id="revenueChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Dual Charts Container -->
                    <div class="dual-charts-container" id="dualChartsContainer">
                        <div class="chart-container dual">
                            <canvas id="revenueChartDual"></canvas>
                        </div>
                        <div class="chart-container dual">
                            <canvas id="ordersChartDual"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Key Insights -->
                <div class="insights-section">
                    <div class="section-header">
                        <h3 class="section-title">Key Insights</h3>
                    </div>
                    <div id="insightsContainer">
                        <div class="insight-item">
                            <div class="insight-title">Loading insights...</div>
                            <div class="insight-description">Analyzing your data to provide actionable insights.</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Popular Items -->
            <div class="table-container">
                <div class="section-header">
                    <h3 class="section-title">Popular Menu Items</h3>
                </div>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Item Name</th>
                            <th>Orders</th>
                            <th>Revenue</th>
                            <th>Performance</th>
                        </tr>
                    </thead>
                    <tbody id="popularItemsTable">
                        <tr>
                            <td colspan="4" style="text-align: center; padding: 40px;">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Customer Analytics -->
            <div class="table-container">
                <div class="section-header">
                    <h3 class="section-title">Customer Insights</h3>
                </div>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="repeatCustomers">0%</div>
                        <div class="metric-label">Repeat Customers</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="avgOrdersPerCustomer">0</div>
                        <div class="metric-label">Avg Orders/Customer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="peakHour">12 PM</div>
                        <div class="metric-label">Peak Hour</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="avgPrepTime">15 min</div>
                        <div class="metric-label">Avg Prep Time</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentUser = null;
        let currentRestaurant = null;
        let currentTimePeriod = 'month';
        let analyticsData = {};
        let charts = {};
        
        // Restaurant timezone and currency
        let restaurantTimezone = 'UTC';
        let restaurantCurrency = { code: 'USD', symbol: '$' };

        // ============================================================================
        // RESTAURANT TIMEZONE & CURRENCY MANAGEMENT (FROM INCIDENT REPORTS)
        // ============================================================================

        /**
         * Get restaurant's effective timezone (venue timezone if associated, own timezone if independent)
         */
        function getRestaurantEffectiveTimezone() {
            if (typeof TimezoneAPI !== 'undefined' && TimezoneAPI.getRestaurantEffectiveTimezone) {
                return TimezoneAPI.getRestaurantEffectiveTimezone(currentRestaurant);
            }
            
            // Fallback logic
            if (currentRestaurant.venueId && currentRestaurant.venueTimezone) {
                return currentRestaurant.venueTimezone;
            }
            
            return currentRestaurant.timezone || 'UTC';
        }

        /**
         * Get restaurant's effective currency
         */
        function getRestaurantCurrency() {
            if (currentRestaurant.currency) {
                return currentRestaurant.currency;
            }
            
            // Fallback
            return { code: 'USD', symbol: '$', name: 'US Dollar' };
        }

        /**
         * Format currency using restaurant's currency
         */
        function formatCurrency(amount) {
            if (!amount && amount !== 0) return `${restaurantCurrency.symbol}0.00`;
            return `${restaurantCurrency.symbol}${Number(amount).toFixed(2)}`;
        }

        // ============================================================================
        // CALENDAR-BASED TIME PERIOD LOGIC (FROM INCIDENT REPORTS)
        // ============================================================================

        /**
         * Get calendar-based time period boundaries in restaurant's timezone
         */
        function getCalendarPeriodBoundaries(timePeriod) {
            try {
                if (typeof TimezoneAPI !== 'undefined' && TimezoneAPI.getCalendarPeriodBoundaries) {
                    // Convert analytics format to TimezoneAPI format
                    const periodMapping = {
                        'today': 'today',
                        'week': 'thisweek', 
                        'month': 'thismonth',
                        'quarter': 'thisquarter',
                        'year': 'thisyear'
                    };
                    
                    const mappedPeriod = periodMapping[timePeriod.toLowerCase()] || timePeriod;
                    console.log('üîÑ Period mapping:', timePeriod, '‚Üí', mappedPeriod);
                    return TimezoneAPI.getCalendarPeriodBoundaries(mappedPeriod, currentRestaurant);
                }
                
                // Fallback calendar logic
                const now = new Date();
                const nowInTimezone = new Date(now.toLocaleString('en-US', { timeZone: restaurantTimezone }));
                
                switch (timePeriod.toLowerCase()) {
                    case 'today':
                        const todayStart = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth(), nowInTimezone.getDate());
                        const todayEnd = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth(), nowInTimezone.getDate(), 23, 59, 59, 999);
                        return { start: todayStart, end: todayEnd };
                        
                    case 'week':
                        // Get current week Monday to Sunday
                        const dayOfWeek = nowInTimezone.getDay();
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const weekStart = new Date(nowInTimezone);
                        weekStart.setDate(nowInTimezone.getDate() + mondayOffset);
                        weekStart.setHours(0, 0, 0, 0);
                        
                        const weekEnd = new Date(weekStart);
                        weekEnd.setDate(weekStart.getDate() + 6);
                        weekEnd.setHours(23, 59, 59, 999);
                        return { start: weekStart, end: weekEnd };
                        
                    case 'month':
                        // Get current month 1st to last day
                        const monthStart = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth(), 1);
                        const monthEnd = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth() + 1, 0, 23, 59, 59, 999);
                        return { start: monthStart, end: monthEnd };
                        
                    case 'quarter':
                        // Get current quarter start to end
                        const quarterStartMonth = Math.floor(nowInTimezone.getMonth() / 3) * 3;
                        const quarterStart = new Date(nowInTimezone.getFullYear(), quarterStartMonth, 1);
                        const quarterEnd = new Date(nowInTimezone.getFullYear(), quarterStartMonth + 3, 0, 23, 59, 59, 999);
                        return { start: quarterStart, end: quarterEnd };
                        
                    case 'year':
                        // Get current year January 1st to December 31st
                        const yearStart = new Date(nowInTimezone.getFullYear(), 0, 1);
                        const yearEnd = new Date(nowInTimezone.getFullYear(), 11, 31, 23, 59, 59, 999);
                        return { start: yearStart, end: yearEnd };
                        
                    default:
                        console.warn('‚ö†Ô∏è Unknown time period, defaulting to today:', timePeriod);
                        const defaultStart = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth(), nowInTimezone.getDate());
                        const defaultEnd = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth(), nowInTimezone.getDate(), 23, 59, 59, 999);
                        return { start: defaultStart, end: defaultEnd };
                }
            } catch (error) {
                console.error('‚ùå Error getting calendar period boundaries:', error);
                const fallbackStart = new Date();
                fallbackStart.setHours(0, 0, 0, 0);
                const fallbackEnd = new Date();
                fallbackEnd.setHours(23, 59, 59, 999);
                return { start: fallbackStart, end: fallbackEnd };
            }
        }

        /**
         * Convert timestamp to date in restaurant's timezone
         */
        function timestampToDate(timestamp) {
            try {
                if (typeof TimezoneAPI !== 'undefined' && TimezoneAPI.timestampToDateInTimezone) {
                    return TimezoneAPI.timestampToDateInTimezone(timestamp, currentRestaurant);
                }
                
                // Fallback conversion
                let date;
                if (timestamp && timestamp.toDate) {
                    date = timestamp.toDate();
                } else if (timestamp && timestamp.seconds) {
                    date = new Date(timestamp.seconds * 1000);
                } else {
                    date = new Date(timestamp);
                }
                
                // Convert to restaurant timezone
                return new Date(date.toLocaleString('en-US', { timeZone: restaurantTimezone }));
            } catch (error) {
                console.error('‚ùå Timestamp conversion error:', error);
                return new Date();
            }
        }

        /**
         * Filter orders by calendar time period in restaurant's timezone
         */
        function filterOrdersByTimePeriod(orders, timePeriod) {
            try {
                // Use the same period mapping as getCalendarPeriodBoundaries
                const periodMapping = {
                    'today': 'today',
                    'week': 'thisweek', 
                    'month': 'thismonth',
                    'quarter': 'thisquarter',
                    'year': 'thisyear'
                };
                
                const mappedPeriod = periodMapping[timePeriod.toLowerCase()] || timePeriod;
                console.log('üîç Filtering orders with period mapping:', timePeriod, '‚Üí', mappedPeriod);
                
                if (typeof TimezoneAPI !== 'undefined' && TimezoneAPI.filterOrdersByTimePeriod) {
                    return TimezoneAPI.filterOrdersByTimePeriod(orders, mappedPeriod, currentRestaurant);
                }
                
                // Fallback filtering
                const boundaries = getCalendarPeriodBoundaries(timePeriod);
                if (!boundaries.start || !boundaries.end) return orders;
                
                return orders.filter(order => {
                    const orderDate = timestampToDate(order.createdAt);
                    return orderDate >= boundaries.start && orderDate <= boundaries.end;
                });
            } catch (error) {
                console.error('‚ùå Error filtering orders by time period:', error);
                return orders;
            }
        }

        /**
         * Get previous calendar period for comparison (using TimezoneAPI)
         */
        function getPreviousCalendarPeriod(timePeriod) {
            try {
                if (typeof TimezoneAPI !== 'undefined' && TimezoneAPI.getPreviousCalendarPeriod) {
                    const periodMapping = {
                        'today': 'today',
                        'week': 'thisweek', 
                        'month': 'thismonth',
                        'quarter': 'thisquarter',
                        'year': 'thisyear'
                    };
                    
                    const mappedPeriod = periodMapping[timePeriod.toLowerCase()] || timePeriod;
                    console.log('üìÖ Previous period mapping:', timePeriod, '‚Üí', mappedPeriod);
                    return TimezoneAPI.getPreviousCalendarPeriod(mappedPeriod, currentRestaurant);
                }
                
                // Fallback to previous period calculation
                const now = new Date();
                const nowInTimezone = new Date(now.toLocaleString('en-US', { timeZone: restaurantTimezone }));
                let start, end;
                
                switch (timePeriod.toLowerCase()) {
                    case 'today':
                        // Yesterday
                        start = new Date(nowInTimezone);
                        start.setDate(nowInTimezone.getDate() - 1);
                        start.setHours(0, 0, 0, 0);
                        
                        end = new Date(start);
                        end.setHours(23, 59, 59, 999);
                        break;
                        
                    case 'week':
                        // Last week (same Monday-Sunday)
                        const dayOfWeek = nowInTimezone.getDay();
                        const lastMondayOffset = dayOfWeek === 0 ? -13 : -6 - dayOfWeek;
                        start = new Date(nowInTimezone);
                        start.setDate(nowInTimezone.getDate() + lastMondayOffset);
                        start.setHours(0, 0, 0, 0);
                        
                        end = new Date(start);
                        end.setDate(start.getDate() + 6);
                        end.setHours(23, 59, 59, 999);
                        break;
                        
                    case 'month':
                        // Last month (1st to end)
                        start = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth() - 1, 1, 0, 0, 0);
                        end = new Date(nowInTimezone.getFullYear(), nowInTimezone.getMonth(), 0, 23, 59, 59);
                        break;
                        
                    case 'quarter':
                        // Previous quarter
                        const currentQuarter = Math.floor(nowInTimezone.getMonth() / 3);
                        const prevQuarter = currentQuarter === 0 ? 3 : currentQuarter - 1;
                        const prevYear = currentQuarter === 0 ? nowInTimezone.getFullYear() - 1 : nowInTimezone.getFullYear();
                        
                        start = new Date(prevYear, prevQuarter * 3, 1, 0, 0, 0);
                        end = new Date(prevYear, prevQuarter * 3 + 3, 0, 23, 59, 59);
                        break;
                        
                    case 'year':
                        // Last year
                        start = new Date(nowInTimezone.getFullYear() - 1, 0, 1, 0, 0, 0);
                        end = new Date(nowInTimezone.getFullYear() - 1, 11, 31, 23, 59, 59);
                        break;
                        
                    default:
                        // Default to yesterday
                        start = new Date(nowInTimezone);
                        start.setDate(nowInTimezone.getDate() - 1);
                        start.setHours(0, 0, 0, 0);
                        
                        end = new Date(start);
                        end.setHours(23, 59, 59, 999);
                }
                
                return { start, end, timezone: restaurantTimezone };
                
            } catch (error) {
                console.error('‚ùå Get previous calendar period error:', error);
                const fallbackStart = new Date();
                fallbackStart.setDate(fallbackStart.getDate() - 1);
                fallbackStart.setHours(0, 0, 0, 0);
                
                const fallbackEnd = new Date(fallbackStart);
                fallbackEnd.setHours(23, 59, 59, 999);
                
                return { 
                    start: fallbackStart, 
                    end: fallbackEnd, 
                    timezone: restaurantTimezone 
                };
            }
        }

        // ============================================================================
        // SMART CHART ADAPTATIONS (FROM INCIDENT REPORTS)
        // ============================================================================

        /**
         * Generate smart chart data based on period type and restaurant timezone
         */
        function generateTimeSeriesData(orders, timePeriod) {
            const boundaries = getCalendarPeriodBoundaries(timePeriod);
            const labels = [];
            const revenueData = [];
            const ordersData = [];
            
            try {
                switch (timePeriod.toLowerCase()) {
                    case 'today':
                        // Hourly breakdown for today
                        for (let hour = 0; hour < 24; hour++) {
                            const hourData = { revenue: 0, orders: 0 };
                            
                            orders.forEach(order => {
                                const orderDate = timestampToDate(order.createdAt);
                                if (orderDate.getHours() === hour) {
                                    hourData.revenue += order.total || 0;
                                    hourData.orders += 1;
                                }
                            });
                            
                            labels.push(`${hour}:00`);
                            revenueData.push(hourData.revenue);
                            ordersData.push(hourData.orders);
                        }
                        break;
                        
                    case 'week':
                        // Daily breakdown for the week (Mon-Sun)
                        const weekDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                        for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
                            const currentDay = new Date(boundaries.start);
                            currentDay.setDate(boundaries.start.getDate() + dayOffset);
                            
                            const dayData = { revenue: 0, orders: 0 };
                            
                            orders.forEach(order => {
                                const orderDate = timestampToDate(order.createdAt);
                                if (orderDate.toDateString() === currentDay.toDateString()) {
                                    dayData.revenue += order.total || 0;
                                    dayData.orders += 1;
                                }
                            });
                            
                            labels.push(weekDays[dayOffset]);
                            revenueData.push(dayData.revenue);
                            ordersData.push(dayData.orders);
                        }
                        break;
                        
                    case 'month':
                        // Daily breakdown for the month
                        const daysInMonth = new Date(boundaries.end.getFullYear(), boundaries.end.getMonth() + 1, 0).getDate();
                        for (let day = 1; day <= daysInMonth; day++) {
                            const currentDay = new Date(boundaries.start.getFullYear(), boundaries.start.getMonth(), day);
                            
                            const dayData = { revenue: 0, orders: 0 };
                            
                            orders.forEach(order => {
                                const orderDate = timestampToDate(order.createdAt);
                                if (orderDate.toDateString() === currentDay.toDateString()) {
                                    dayData.revenue += order.total || 0;
                                    dayData.orders += 1;
                                }
                            });
                            
                            labels.push(day.toString());
                            revenueData.push(dayData.revenue);
                            ordersData.push(dayData.orders);
                        }
                        break;
                        
                    case 'quarter':
                        // Monthly breakdown for the quarter
                        const quarterStartMonth = boundaries.start.getMonth();
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        for (let monthOffset = 0; monthOffset < 3; monthOffset++) {
                            const currentMonth = quarterStartMonth + monthOffset;
                            const monthStart = new Date(boundaries.start.getFullYear(), currentMonth, 1);
                            const monthEnd = new Date(boundaries.start.getFullYear(), currentMonth + 1, 0, 23, 59, 59, 999);
                            
                            const monthData = { revenue: 0, orders: 0 };
                            
                            orders.forEach(order => {
                                const orderDate = timestampToDate(order.createdAt);
                                if (orderDate >= monthStart && orderDate <= monthEnd) {
                                    monthData.revenue += order.total || 0;
                                    monthData.orders += 1;
                                }
                            });
                            
                            labels.push(monthNames[currentMonth]);
                            revenueData.push(monthData.revenue);
                            ordersData.push(monthData.orders);
                        }
                        break;
                        
                    case 'year':
                        // Monthly breakdown for the year
                        const yearMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        for (let month = 0; month < 12; month++) {
                            const monthStart = new Date(boundaries.start.getFullYear(), month, 1);
                            const monthEnd = new Date(boundaries.start.getFullYear(), month + 1, 0, 23, 59, 59, 999);
                            
                            const monthData = { revenue: 0, orders: 0 };
                            
                            orders.forEach(order => {
                                const orderDate = timestampToDate(order.createdAt);
                                if (orderDate >= monthStart && orderDate <= monthEnd) {
                                    monthData.revenue += order.total || 0;
                                    monthData.orders += 1;
                                }
                            });
                            
                            labels.push(yearMonthNames[month]);
                            revenueData.push(monthData.revenue);
                            ordersData.push(monthData.orders);
                        }
                        break;
                        
                    default:
                        // Fallback to daily grouping
                        const dailyData = {};
                        orders.forEach(order => {
                            const date = timestampToDate(order.createdAt);
                            const dateKey = date.toISOString().split('T')[0];
                            if (!dailyData[dateKey]) {
                                dailyData[dateKey] = { revenue: 0, orders: 0 };
                            }
                            dailyData[dateKey].revenue += order.total || 0;
                            dailyData[dateKey].orders += 1;
                        });
                        
                        const dates = Object.keys(dailyData).sort();
                        labels.push(...dates.map(date => new Date(date).toLocaleDateString()));
                        revenueData.push(...dates.map(date => dailyData[date].revenue));
                        ordersData.push(...dates.map(date => dailyData[date].orders));
                }
                
                return { labels, revenue: revenueData, orders: ordersData };
                
            } catch (error) {
                console.error('‚ùå Error generating chart data:', error);
                return { 
                    labels: [], 
                    revenue: [], 
                    orders: [] 
                };
            }
        }

        /**
         * Update chart title based on selected period and restaurant timezone
         */
        function updateChartTitle(timePeriod) {
            const titleMap = {
                'today': 'Today\'s Revenue & Orders (Hourly)',
                'week': 'This Week\'s Revenue & Orders (Daily)', 
                'month': 'This Month\'s Revenue & Orders (Daily)',
                'quarter': 'This Quarter\'s Revenue & Orders (Monthly)',
                'year': 'This Year\'s Revenue & Orders (Monthly)'
            };
            
            const title = titleMap[timePeriod] || 'Revenue & Order Trends';
            const chartTitleElement = document.getElementById('chartTitle');
            if (chartTitleElement) {
                chartTitleElement.textContent = title;
            }
        }

        // ============================================================================
        // SECURE INITIALIZATION
        // ============================================================================

        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üìä Restaurant Analytics with Calendar Logic & Timezone Support initializing...');
            
            try {
                await initializeAnalytics();
            } catch (error) {
                console.error('‚ùå Failed to initialize analytics:', error);
                showSecurityError(error);
            }
        });

        async function initializeAnalytics() {
            try {
                showLoading(true);
                
                // Step 1: Secure Firebase inheritance and authentication
                console.log('üîê Starting secure initialization...');
                const { user, restaurant } = await initializeRestaurantPage('Analytics');
                
                // Step 2: Set global variables
                currentUser = user;
                currentRestaurant = restaurant;

                console.log('‚úÖ User authenticated:', currentUser.email);
                console.log('‚úÖ Restaurant loaded:', currentRestaurant.name);
                
                // Step 3: Setup restaurant timezone and currency
                restaurantTimezone = getRestaurantEffectiveTimezone();
                restaurantCurrency = getRestaurantCurrency();
                
                console.log('üïê Restaurant timezone:', restaurantTimezone);
                console.log('üí∞ Restaurant currency:', restaurantCurrency);
                
                // Step 4: Setup event listeners
                setupEventListeners();
                
                // Step 5: Load analytics data with calendar-based filtering
                await loadAnalyticsData();
                
                showLoading(false);
                showMainContent(true);

                console.log('‚úÖ Restaurant Analytics with Calendar Logic & Timezone Support initialized successfully');

            } catch (error) {
                console.error('‚ùå Analytics initialization error:', error);
                showError(error.message);
                showLoading(false);
            }
        }

        function setupEventListeners() {
            document.getElementById('timePeriodSelect').addEventListener('change', function(e) {
                currentTimePeriod = e.target.value;
                console.log('üìÖ Time period changed to:', currentTimePeriod);
                loadAnalyticsData();
            });
            
            // Setup chart type selector event listener
            document.getElementById('revenueChartType').addEventListener('change', function() {
                if (analyticsData.orders) {
                    const timeData = generateTimeSeriesData(analyticsData.orders, currentTimePeriod);
                    updateRevenueChart(timeData);
                    updateChartTitle(currentTimePeriod);
                }
            });
        }

        async function loadAnalyticsData() {
            try {
                console.log('üìä Loading analytics data with calendar-based filtering for period:', currentTimePeriod);
                
                // Load all data in parallel
                const [orders, lossIncidents, menuItems, customerProfiles] = await Promise.all([
                    loadOrdersData(),
                    loadLossData(),
                    loadMenuData(),
                    loadCustomerProfiles()
                ]);

                analyticsData = {
                    orders,
                    lossIncidents,
                    menuItems,
                    customerProfiles,
                    timePeriod: currentTimePeriod
                };

                // Calculate analytics with timezone-aware filtering
                const analytics = calculateAnalytics(analyticsData);
                
                // Update UI with calendar-based data
                updateKPIs(analytics);
                updateCharts(analytics);
                updateInsights(analytics);
                updateTables(analytics, analyticsData.orders);
                
            } catch (error) {
                console.error('‚ùå Error loading analytics data:', error);
                showError('Failed to load analytics data: ' + error.message);
            }
        }

        async function loadOrdersData() {
            try {
                console.log('üì¶ Loading orders data with calendar-based filtering...');
                
                // Get ALL orders first (we'll filter them with calendar logic)
                let allOrders = [];
                
                if (typeof VediAPI?.getOrders === 'function') {
                    console.log('‚úÖ Using iframe VediAPI.getOrders');
                    allOrders = await VediAPI.getOrders(currentRestaurant.id, {
                        limit: 2000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else if (window.parent?.VediAPI?.getOrders) {
                    console.log('üîß Using parent window VediAPI.getOrders');
                    allOrders = await window.parent.VediAPI.getOrders(currentRestaurant.id, {
                        limit: 2000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else if (window.parent?.getOrders) {
                    console.log('üîß Using parent window getOrders');
                    allOrders = await window.parent.getOrders(currentRestaurant.id, {
                        limit: 2000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else {
                    console.warn('‚ö†Ô∏è No getOrders function available');
                    return [];
                }
                
                console.log('üì¶ Raw orders from Firebase:', allOrders.length);
                
                // Filter by current time period using calendar logic and restaurant timezone
                const filteredOrders = filterOrdersByTimePeriod(allOrders, currentTimePeriod);
                console.log('üì¶ Filtered orders for', currentTimePeriod, ':', filteredOrders.length);
                console.log('üïê Using restaurant timezone:', restaurantTimezone);
                
                return filteredOrders;
            } catch (error) {
                console.error('‚ùå Error loading orders:', error);
                return [];
            }
        }

        async function loadLossData() {
            try {
                console.log('üìâ Loading loss incidents with calendar-based filtering...');
                
                // Get ALL incidents first, then filter with calendar logic
                let allIncidents = [];
                
                if (typeof VediAPI?.getLossIncidents === 'function') {
                    allIncidents = await VediAPI.getLossIncidents(currentRestaurant.id, {
                        limit: 1000
                    });
                } else {
                    console.warn('‚ö†Ô∏è No getLossIncidents function available');
                    return [];
                }
                
                // Filter by current time period using same logic as orders
                const filteredIncidents = allIncidents.filter(incident => {
                    const boundaries = getCalendarPeriodBoundaries(currentTimePeriod);
                    if (!boundaries.start || !boundaries.end) return true;
                    
                    const incidentDate = timestampToDate(incident.createdAt);
                    return incidentDate >= boundaries.start && incidentDate <= boundaries.end;
                });
                
                console.log('üìâ Filtered loss incidents for', currentTimePeriod, ':', filteredIncidents.length);
                return filteredIncidents;
            } catch (error) {
                console.error('‚ùå Error loading loss data:', error);
                return [];
            }
        }

        async function loadMenuData() {
            try {
                const menuItems = await VediAPI.getMenuItems(currentRestaurant.id);
                console.log('üçΩÔ∏è Loaded menu items:', menuItems.length);
                return menuItems;
            } catch (error) {
                console.error('‚ùå Error loading menu data:', error);
                return [];
            }
        }

        async function loadCustomerProfiles() {
            try {
                console.log('üë• Loading customer profiles...');
                
                let customerProfiles = [];
                
                if (typeof VediAPI?.getCustomerProfiles === 'function') {
                    console.log('‚úÖ Using iframe VediAPI.getCustomerProfiles');
                    customerProfiles = await VediAPI.getCustomerProfiles(currentRestaurant.id, {
                        limit: 1000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else if (window.parent?.VediAPI?.getCustomerProfiles) {
                    console.log('üîß Using parent window VediAPI.getCustomerProfiles');
                    customerProfiles = await window.parent.VediAPI.getCustomerProfiles(currentRestaurant.id, {
                        limit: 1000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else if (window.parent?.getCustomerProfiles) {
                    console.log('üîß Using parent window getCustomerProfiles');
                    customerProfiles = await window.parent.getCustomerProfiles(currentRestaurant.id, {
                        limit: 1000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else {
                    console.warn('‚ö†Ô∏è No getCustomerProfiles function available');
                    return [];
                }
                
                console.log('üë• Total customer profiles loaded:', customerProfiles.length);
                
                return customerProfiles;
            } catch (error) {
                console.error('‚ùå Error loading customer profiles:', error);
                return [];
            }
        }

        function calculateAnalytics(data) {
            console.log('üî¢ Calculating analytics with calendar-based data:', data);
            const { orders, lossIncidents, menuItems, customerProfiles } = data;
            
            console.log('üìä Processing orders (calendar-filtered):', orders.length);
            console.log('üìâ Processing loss incidents (calendar-filtered):', lossIncidents.length);
            console.log('üçΩÔ∏è Processing menu items:', menuItems.length);
            console.log('üë• Processing customer profiles:', customerProfiles.length);
            
            // Basic KPIs with timezone-aware data
            const totalRevenue = orders.reduce((sum, order) => {
                const orderTotal = order.total || 0;
                return sum + orderTotal;
            }, 0);
            
            const totalOrders = orders.length;
            const completedOrders = orders.filter(order => order.status === 'completed');
            const totalLosses = lossIncidents.reduce((sum, incident) => sum + (incident.amount || 0), 0);
            
            console.log('üí∞ Total revenue (calendar period):', totalRevenue);
            console.log('üì¶ Total orders (calendar period):', totalOrders);
            console.log('‚úÖ Completed orders:', completedOrders.length);
            console.log('üìâ Total losses (calendar period):', totalLosses);
            
            // Customer analytics using customer profiles
            const uniqueCustomers = customerProfiles.length;
            const avgOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;
            
            console.log('üë• Unique customers (from profiles):', uniqueCustomers);
            console.log('üéØ Average order value:', avgOrderValue);
            
            // Popular items analysis (calendar-filtered orders)
            const itemStats = {};
            orders.forEach(order => {
                if (order.items && Array.isArray(order.items)) {
                    order.items.forEach(item => {
                        if (!itemStats[item.name]) {
                            itemStats[item.name] = { count: 0, revenue: 0 };
                        }
                        itemStats[item.name].count += item.quantity || 1;
                        itemStats[item.name].revenue += (item.price || 0) * (item.quantity || 1);
                    });
                }
            });
            
            const popularItems = Object.entries(itemStats)
                .map(([name, stats]) => ({ name, ...stats }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);
                
            console.log('üçΩÔ∏è Popular items (calendar period):', popularItems);

            // Time-based data for charts using calendar logic
            const timeData = generateTimeSeriesData(orders, data.timePeriod);
            console.log('üìà Time series data (calendar-based):', timeData);

            // Calculate customer metrics using timezone-aware data
            const customerMetrics = calculateRealCustomerMetrics(orders, customerProfiles);
            console.log('üë• Customer metrics (calendar period):', customerMetrics);

            const analytics = {
                kpis: {
                    totalRevenue,
                    totalOrders,
                    uniqueCustomers,
                    avgOrderValue,
                    totalLosses,
                    completedOrders: completedOrders.length
                },
                popularItems,
                timeData,
                customerMetrics,
                insights: generateInsights({ orders, lossIncidents, menuItems, customerProfiles })
            };
            
            console.log('‚úÖ Final analytics calculated (calendar-based):', analytics);
            return analytics;
        }

        function calculateRealCustomerMetrics(orders, customerProfiles = []) {
            // Calculate actual average preparation time using timezone-aware dates
            const completedOrders = orders.filter(order => order.status === 'completed');
            let totalPrepTime = 0;
            let ordersWithPrepTime = 0;
            
            completedOrders.forEach(order => {
                if (order.createdAt && order.updatedAt) {
                    const created = timestampToDate(order.createdAt);
                    const updated = timestampToDate(order.updatedAt);
                    const prepTime = (updated - created) / (1000 * 60); // minutes
                    
                    if (prepTime > 0 && prepTime < 180) { // Reasonable prep time (under 3 hours)
                        totalPrepTime += prepTime;
                        ordersWithPrepTime++;
                    }
                }
            });
            
            const avgPrepTime = ordersWithPrepTime > 0 ? 
                `${Math.round(totalPrepTime / ordersWithPrepTime)} min` : 
                'No data';

            // Calculate real customer data using actual customer profiles
            const customerOrderData = {};
            
            if (customerProfiles && customerProfiles.length > 0) {
                // Map orders to customer profiles
                customerProfiles.forEach(customer => {
                    const customerPhone = customer.phone || customer.phoneNumber;
                    const customerEmail = customer.email;
                    
                    customerOrderData[customer.id] = {
                        profile: customer,
                        orders: [],
                        orderCount: 0,
                        revenue: 0,
                        phone: customerPhone,
                        email: customerEmail
                    };
                });
                
                // Associate calendar-filtered orders with customer profiles
                orders.forEach(order => {
                    let matchedCustomerId = null;
                    
                    // Try to match by phone number
                    if (order.customerPhone) {
                        for (const [customerId, customerData] of Object.entries(customerOrderData)) {
                            if (customerData.phone && 
                                (customerData.phone === order.customerPhone || 
                                 customerData.phone.replace(/[^\d]/g, '') === order.customerPhone.replace(/[^\d]/g, ''))) {
                                matchedCustomerId = customerId;
                                break;
                            }
                        }
                    }
                    
                    // Try to match by email if phone didn't work
                    if (!matchedCustomerId && order.customerEmail) {
                        for (const [customerId, customerData] of Object.entries(customerOrderData)) {
                            if (customerData.email && customerData.email === order.customerEmail) {
                                matchedCustomerId = customerId;
                                break;
                            }
                        }
                    }
                    
                    // Associate order with customer if match found
                    if (matchedCustomerId) {
                        customerOrderData[matchedCustomerId].orders.push(order);
                        customerOrderData[matchedCustomerId].orderCount += 1;
                        customerOrderData[matchedCustomerId].revenue += order.total || 0;
                    }
                });
            }

            const totalCustomers = customerProfiles ? customerProfiles.length : 0;
            const customersWithOrders = Object.values(customerOrderData).filter(customer => customer.orderCount > 0);
            const repeatCustomers = customersWithOrders.filter(customer => customer.orderCount > 1).length;
            const repeatRate = customersWithOrders.length > 0 ? (repeatCustomers / customersWithOrders.length) * 100 : 0;
            
            const avgOrdersPerCustomer = customersWithOrders.length > 0 ? 
                customersWithOrders.reduce((sum, customer) => sum + customer.orderCount, 0) / customersWithOrders.length : 0;

            // Calculate actual peak hour from calendar-filtered orders using restaurant timezone
            const hourlyOrders = {};
            orders.forEach(order => {
                const hour = timestampToDate(order.createdAt).getHours();
                hourlyOrders[hour] = (hourlyOrders[hour] || 0) + 1;
            });
            
            let peakHour = 12; // default
            let maxOrders = 0;
            
            Object.entries(hourlyOrders).forEach(([hour, count]) => {
                if (count > maxOrders) {
                    maxOrders = count;
                    peakHour = parseInt(hour);
                }
            });
            
            const peakHourFormatted = peakHour === 0 ? '12 AM' :
                                    peakHour < 12 ? `${peakHour} AM` :
                                    peakHour === 12 ? '12 PM' :
                                    `${peakHour - 12} PM`;

            return {
                repeatRate,
                avgOrdersPerCustomer,
                peakHour: maxOrders > 0 ? peakHourFormatted : 'No data',
                avgPrepTime,
                totalCustomers,
                customersWithOrders: customersWithOrders.length
            };
        }

        function generateInsights(data) {
            const insights = [];
            const { orders, lossIncidents, customerProfiles } = data;

            // Revenue insights (calendar period)
            const totalRevenue = orders.reduce((sum, order) => sum + (order.total || 0), 0);
            if (totalRevenue > 0) {
                insights.push({
                    type: 'positive',
                    title: 'Revenue Performance',
                    description: `Generated ${formatCurrency(totalRevenue)} in revenue with ${orders.length} orders for the selected period.`
                });
            }

            // Customer insights
            if (customerProfiles.length > 0) {
                const customersWithOrders = customerProfiles.filter(customer => {
                    return orders.some(order => 
                        order.customerPhone === customer.phone || 
                        order.customerPhone === customer.phoneNumber ||
                        order.customerEmail === customer.email
                    );
                }).length;
                
                const engagementRate = (customersWithOrders / customerProfiles.length) * 100;
                
                if (engagementRate >= 80) {
                    insights.push({
                        type: 'positive',
                        title: 'High Customer Engagement',
                        description: `${engagementRate.toFixed(1)}% of registered customers have placed orders in this period.`
                    });
                } else if (engagementRate < 50) {
                    insights.push({
                        type: 'warning',
                        title: 'Customer Engagement Opportunity',
                        description: `Only ${engagementRate.toFixed(1)}% of registered customers have placed orders in this period. Consider engagement campaigns.`
                    });
                }
            }

            // Loss insights (calendar period)
            const totalLoss = lossIncidents.reduce((sum, incident) => sum + (incident.amount || 0), 0);
            if (totalLoss > 0) {
                const lossPercentage = totalRevenue > 0 ? (totalLoss / totalRevenue) * 100 : 0;
                insights.push({
                    type: lossPercentage > 5 ? 'negative' : 'warning',
                    title: 'Loss Management',
                    description: `${lossIncidents.length} incidents resulted in ${formatCurrency(totalLoss)} in losses (${lossPercentage.toFixed(1)}% of revenue) during this period.`
                });
            }

            // Performance insights (calendar period)
            const completedOrders = orders.filter(order => order.status === 'completed').length;
            const completionRate = orders.length > 0 ? (completedOrders / orders.length) * 100 : 0;
            
            if (completionRate >= 95) {
                insights.push({
                    type: 'positive',
                    title: 'Excellent Order Completion',
                    description: `${completionRate.toFixed(1)}% order completion rate shows excellent operational efficiency for this period.`
                });
            } else if (completionRate < 85) {
                insights.push({
                    type: 'warning',
                    title: 'Order Completion Needs Attention',
                    description: `${completionRate.toFixed(1)}% completion rate is below optimal for this period. Consider reviewing processes.`
                });
            }

            return insights;
        }

        function updateKPIs(analytics) {
            const { kpis } = analytics;

            document.getElementById('totalRevenue').textContent = formatCurrency(kpis.totalRevenue);
            document.getElementById('totalOrders').textContent = kpis.totalOrders.toLocaleString();
            document.getElementById('uniqueCustomers').textContent = kpis.uniqueCustomers.toLocaleString();
            document.getElementById('avgOrderValue').textContent = formatCurrency(kpis.avgOrderValue);
            document.getElementById('totalLosses').textContent = formatCurrency(kpis.totalLosses);

            // Calculate real period-over-period changes using calendar periods
            calculateAndUpdateChanges(analytics);
        }

        async function calculateAndUpdateChanges(analytics) {
            try {
                // Get previous calendar period data for comparison
                const previousPeriodData = await getPreviousPeriodData();
                
                if (previousPeriodData.orders.length > 0) {
                    const currentRevenue = analytics.kpis.totalRevenue;
                    const previousRevenue = previousPeriodData.revenue;
                    const revenueChange = calculatePercentageChange(currentRevenue, previousRevenue);
                    updateChangeIndicator('revenueChange', revenueChange);
                    
                    const currentOrders = analytics.kpis.totalOrders;
                    const previousOrders = previousPeriodData.orders.length;
                    const ordersChange = calculatePercentageChange(currentOrders, previousOrders);
                    updateChangeIndicator('ordersChange', ordersChange);
                    
                    const currentCustomers = analytics.kpis.uniqueCustomers;
                    const previousCustomers = previousPeriodData.customerProfiles ? previousPeriodData.customerProfiles.length : 0;
                    const customersChange = calculatePercentageChange(currentCustomers, previousCustomers);
                    updateChangeIndicator('customersChange', customersChange);
                    
                    const currentAOV = analytics.kpis.avgOrderValue;
                    const previousAOV = previousOrders > 0 ? previousRevenue / previousOrders : 0;
                    const aovChange = calculatePercentageChange(currentAOV, previousAOV);
                    updateChangeIndicator('aovChange', aovChange);
                } else {
                    // No previous data available
                    updateChangeIndicator('revenueChange', 'No comparison data');
                    updateChangeIndicator('ordersChange', 'No comparison data');
                    updateChangeIndicator('customersChange', 'No comparison data');
                    updateChangeIndicator('aovChange', 'No comparison data');
                }
                
                const lossCount = analyticsData.lossIncidents.length;
                const lossText = lossCount === 0 ? 'No incidents' : `${lossCount} incident${lossCount > 1 ? 's' : ''}`;
                updateChangeIndicator('lossesChange', lossText, lossCount > 0 ? 'negative' : 'neutral');
                
            } catch (error) {
                console.error('Error calculating changes:', error);
                // Show neutral indicators if calculation fails
                updateChangeIndicator('revenueChange', 'Data unavailable');
                updateChangeIndicator('ordersChange', 'Data unavailable'); 
                updateChangeIndicator('customersChange', 'Data unavailable');
                updateChangeIndicator('aovChange', 'Data unavailable');
                updateChangeIndicator('lossesChange', 'Data unavailable');
            }
        }

        async function getPreviousPeriodData() {
            try {
                // Get previous calendar period boundaries using TimezoneAPI
                const previousPeriod = getPreviousCalendarPeriod(currentTimePeriod);
                
                console.log('üìÖ Getting previous period data:', currentTimePeriod, '‚Üí', previousPeriod);
                
                // Get orders from previous period using multiple fallback options
                let allOrders = [];
                
                if (typeof VediAPI?.getOrders === 'function') {
                    allOrders = await VediAPI.getOrders(currentRestaurant.id, {
                        limit: 2000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else if (window.parent?.VediAPI?.getOrders) {
                    allOrders = await window.parent.VediAPI.getOrders(currentRestaurant.id, {
                        limit: 2000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else if (window.parent?.getOrders) {
                    allOrders = await window.parent.getOrders(currentRestaurant.id, {
                        limit: 2000,
                        orderBy: 'createdAt',
                        orderDirection: 'desc'
                    });
                } else {
                    console.warn('‚ö†Ô∏è No getOrders function available for previous period data');
                    return { orders: [], revenue: 0 };
                }
                
                // Filter orders to previous calendar period using timezone-aware logic
                const previousOrders = allOrders.filter(order => {
                    const orderDate = timestampToDate(order.createdAt);
                    return orderDate >= previousPeriod.start && orderDate <= previousPeriod.end;
                });
                
                const previousRevenue = previousOrders.reduce((sum, order) => sum + (order.total || 0), 0);
                
                console.log('üìä Previous period orders:', previousOrders.length, 'Revenue:', previousRevenue);
                
                return { orders: previousOrders, revenue: previousRevenue };
                
            } catch (error) {
                console.error('Error getting previous period data:', error);
                return { orders: [], revenue: 0 };
            }
        }

        function calculatePercentageChange(current, previous) {
            if (previous === 0) {
                return current > 0 ? '+‚àû%' : '0%';
            }
            
            const change = ((current - previous) / previous) * 100;
            const sign = change >= 0 ? '+' : '';
            return `${sign}${change.toFixed(1)}%`;
        }

        function updateChangeIndicator(elementId, text, type = null) {
            const element = document.getElementById(elementId);
            
            // Auto-determine type from text if not provided
            if (!type) {
                if (text.includes('+') && !text.includes('‚àû')) {
                    type = 'positive';
                } else if (text.includes('-')) {
                    type = 'negative';
                } else {
                    type = 'neutral';
                }
            }
            
            element.className = `kpi-change ${type}`;
            element.innerHTML = `<span>${text}</span>`;
        }

        function updateCharts(analytics) {
            updateRevenueChart(analytics.timeData);
            updateChartTitle(currentTimePeriod);
        }

        function updateRevenueChart(timeData) {
            const chartType = document.getElementById('revenueChartType').value;
            
            if (chartType === 'both') {
                // Show dual charts
                document.getElementById('singleChartContainer').classList.add('hide');
                document.getElementById('dualChartsContainer').classList.add('show');
                
                // Destroy existing charts
                if (charts.revenue) {
                    charts.revenue.destroy();
                }
                if (charts.revenueDual) {
                    charts.revenueDual.destroy();
                }
                if (charts.ordersDual) {
                    charts.ordersDual.destroy();
                }
                
                // Create revenue chart
                const revenueCtx = document.getElementById('revenueChartDual').getContext('2d');
                charts.revenueDual = new Chart(revenueCtx, {
                    type: 'line',
                    data: {
                        labels: timeData.labels,
                        datasets: [{
                            label: `Revenue (${restaurantCurrency.code})`,
                            data: timeData.revenue,
                            borderColor: '#34C759',
                            backgroundColor: 'rgba(52, 199, 89, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `Revenue (${restaurantCurrency.code})`
                                },
                                grid: {
                                    display: false
                                },
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            },
                            x: {
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Revenue: ${formatCurrency(context.parsed.y)}`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Create orders chart
                const ordersCtx = document.getElementById('ordersChartDual').getContext('2d');
                charts.ordersDual = new Chart(ordersCtx, {
                    type: 'line',
                    data: {
                        labels: timeData.labels,
                        datasets: [{
                            label: 'Orders',
                            data: timeData.orders,
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Orders'
                                },
                                ticks: {
                                    stepSize: 1,
                                    callback: function(value) {
                                        if (Number.isInteger(value)) {
                                            return value;
                                        }
                                    }
                                },
                                grid: {
                                    display: false
                                }
                            },
                            x: {
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Orders: ${context.parsed.y}`;
                                    }
                                }
                            }
                        }
                    }
                });
                
            } else {
                // Show single chart
                document.getElementById('singleChartContainer').classList.remove('hide');
                document.getElementById('dualChartsContainer').classList.remove('show');
                
                // Destroy dual charts
                if (charts.revenueDual) {
                    charts.revenueDual.destroy();
                }
                if (charts.ordersDual) {
                    charts.ordersDual.destroy();
                }
                
                const ctx = document.getElementById('revenueChart').getContext('2d');
                
                if (charts.revenue) {
                    charts.revenue.destroy();
                }

                let datasets = [];

                if (chartType === 'revenue') {
                    datasets.push({
                        label: `Revenue (${restaurantCurrency.code})`,
                        data: timeData.revenue,
                        borderColor: '#34C759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        tension: 0.4,
                        fill: true
                    });
                } else if (chartType === 'orders') {
                    datasets.push({
                        label: 'Orders',
                        data: timeData.orders,
                        borderColor: '#007AFF',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    });
                }

                const scales = {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: chartType === 'orders' ? 'Number of Orders' : `Revenue (${restaurantCurrency.code})`
                        },
                        beginAtZero: true,
                        grid: {
                            display: false
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                };

                if (chartType === 'orders') {
                    scales.y.ticks = {
                        stepSize: 1,
                        callback: function(value) {
                            if (Number.isInteger(value)) {
                                return value;
                            }
                        }
                    };
                } else {
                    scales.y.ticks = {
                        callback: function(value) {
                            return formatCurrency(value);
                        }
                    };
                }

                charts.revenue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timeData.labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: scales,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.dataset.label || '';
                                        const value = context.parsed.y;
                                        
                                        if (label.includes('Revenue')) {
                                            return `${label}: ${formatCurrency(value)}`;
                                        } else {
                                            return `${label}: ${value}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        function updateInsights(analytics) {
            const container = document.getElementById('insightsContainer');
            
            if (analytics.insights.length === 0) {
                container.innerHTML = `
                    <div class="insight-item">
                        <div class="insight-title">No insights available</div>
                        <div class="insight-description">More data is needed to generate insights for this period.</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = analytics.insights.map(insight => `
                <div class="insight-item ${insight.type}">
                    <div class="insight-title">${insight.title}</div>
                    <div class="insight-description">${insight.description}</div>
                </div>
            `).join('');
        }

        function updateTables(analytics, orders) {
            // Popular Items Table (calendar-filtered data)
            const popularItemsTable = document.getElementById('popularItemsTable');
            
            if (analytics.popularItems.length === 0) {
                popularItemsTable.innerHTML = `
                    <tr>
                        <td colspan="4" style="text-align: center; padding: 40px;">No order data available for this period</td>
                    </tr>
                `;
            } else {
                popularItemsTable.innerHTML = analytics.popularItems.map((item, index) => `
                    <tr>
                        <td>${item.name}</td>
                        <td>${item.count}</td>
                        <td>${formatCurrency(item.revenue)}</td>
                        <td>
                            <span class="metric-badge ${index < 3 ? 'high' : index < 7 ? 'medium' : 'low'}">
                                ${index < 3 ? 'Top' : index < 7 ? 'Good' : 'Low'}
                            </span>
                        </td>
                    </tr>
                `).join('');
            }

            // Use the customer metrics from analytics (timezone-aware)
            const customerMetrics = analytics.customerMetrics;
            
            document.getElementById('repeatCustomers').textContent = `${customerMetrics.repeatRate.toFixed(1)}%`;
            document.getElementById('avgOrdersPerCustomer').textContent = customerMetrics.avgOrdersPerCustomer.toFixed(1);
            document.getElementById('peakHour').textContent = customerMetrics.peakHour;
            document.getElementById('avgPrepTime').textContent = customerMetrics.avgPrepTime;
        }

        function exportAnalytics() {
            try {
                console.log('üìÑ Exporting analytics report as CSV...');
                
                // Enhanced export with timezone and currency awareness
                const exportData = {
                    restaurant: currentRestaurant.name,
                    period: currentTimePeriod,
                    timezone: restaurantTimezone,
                    currency: restaurantCurrency,
                    exportDate: new Date().toLocaleString('en-US', { timeZone: restaurantTimezone }),
                    analytics: {
                        kpis: analyticsData,
                        summary: {
                            totalRevenue: analyticsData.orders?.reduce((sum, order) => sum + (order.total || 0), 0) || 0,
                            totalOrders: analyticsData.orders?.length || 0,
                            totalLosses: analyticsData.lossIncidents?.reduce((sum, incident) => sum + (incident.amount || 0), 0) || 0,
                            uniqueCustomers: analyticsData.customerProfiles?.length || 0
                        }
                    }
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${currentRestaurant.name.replace(/[^a-zA-Z0-9]/g, '-')}-analytics-${currentTimePeriod}-${new Date().toISOString().split('T')[0]}.json`;
                link.click();

            } catch (error) {
                console.error('Export error:', error);
            }
        }

        function showLoading(show) {
            document.getElementById('loadingSpinner').classList.toggle('show', show);
        }

        function showMainContent(show) {
            document.getElementById('mainContent').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            document.getElementById('errorText').textContent = message;
            document.getElementById('errorMessage').style.display = 'block';
        }

        function showSecurityError(error) {
            console.error('Security error:', error);
            showError('Authentication failed. Please refresh the page.');
        }

        console.log('üìä Restaurant Analytics with Calendar Logic & Timezone Support loaded successfully');
        console.log('üïê NEW: Restaurant timezone awareness with calendar-based time periods');
        console.log('üìÖ NEW: Calendar-based time periods (Mon-Sun weeks, 1st-last day months, Q1-Q4 quarters)');
        console.log('üìä NEW: Smart chart adaptations based on selected period and restaurant timezone');
        console.log('üí∞ NEW: Restaurant currency inheritance and proper formatting');
        console.log('üîÑ Enhanced: All dates and times use restaurant\'s effective timezone');
        console.log('üìÅ Enhanced: Exports include timezone and currency information');
        console.log('üìà Enhanced: Period-over-period comparisons using previous calendar periods');
    </script>
</body>
</html>
